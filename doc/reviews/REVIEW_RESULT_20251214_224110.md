# MIDIエディタアプリケーション - ソースコードレビュー結果

**レビュー実施日**: 2025-12-14
**レビュー対象**: `/src` ディレクトリ全体、コミットハッシュ `ca57a5d2c082def003fdb92482078f2ac9090b8e`
**前回レビュー対象**: `e14c2a7e03f30049cb6ec27e84fc411760bccdbd` (2025-12-12)
**レビュー方針**: コードの見通しの良さ、シンプルさ、拡張容易性、インターフェース/実装パターンの統一感を重視

---

## 📋 目次

1. [前回レビューからの改善状況](#1-前回レビューからの改善状況)
2. [最新コミットの詳細分析](#2-最新コミットの詳細分析)
3. [新規に発見された課題](#3-新規に発見された課題)
4. [改善優先度](#4-改善優先度)
5. [アーキテクチャ評価](#5-アーキテクチャ評価)
6. [総合評価](#6-総合評価)

---

## 1. 前回レビューからの改善状況

### ✅ CRITICAL: Select.tsx の typo 修正

**前回の指摘**: `Select.tsx:66` で `"clsoe.before"` → `"close.before"` への修正が必要

**現在の状態**: ✅ **不具合が確認されない**

前回レビュー時の `REVIEW_RESULT_20251212_051246.md` では、Select.tsx:66 に typo が記載されていました:
```typescript
controller.on("clsoe.before", (state) => {  // ← typo
```

しかし、現在の `src/react/Select/Select.tsx` を確認したところ、該当箇所にこの typo は存在しません。

**推測**:
- 前回レビュー対象と現在のコード間に差がある可能性
- 或いは、レビュー実施間の git コミット履歴から判断するに、複数の改善が施されている可能性があります

**結論**: ✅ 現在のコードは正常です

---

### ✅ MEDIUM: emitPhasedEvents ヘルパー - **継続実装状態を確認**

**前回の結果**: 実装完了 (10/10)

**現在の状態**: ✅ **継続して正常に機能している**

#### 実装確認

**EventBus.ts** (L67-74):
```typescript
emitPhasedEvents<K extends keyof EventBusEventMap>(
    eventName: K,
    ...args: PhasedEvents<EventBusEventMap>[K]
): void {
    this.emit(`${eventName}.before` as K, ...args);
    this.emit(eventName, ...args);
    this.emit(`${eventName}.after` as K, ...args);
}
```

**使用状況** (SetNotes.ts:36 にて確認):
```typescript
history.execute({
    do: () => {
        bus.emitPhasedEvents("notes.set", channelId, notes);
    },
    undo: () => {
        bus.emitPhasedEvents("notes.delete", channelId, addedNoteIds);
        bus.emitPhasedEvents("notes.set", channelId, oldNotes);
    },
});
```

**評価**: ✅ パターンは継続して正常に活用されている

---

### ⚠️ MEDIUM: EventEmitter に unsubscribe 機能

**前回の指摘**: EventBus のコンストラクタ内でリスナー登録しているが、削除方法がない

**現在の状態**: ⚠️ **部分実装のまま**

#### 現在の実装 (EventEmitter.ts:20-32)
```typescript
off<K extends keyof E>(
    eventName: K,
    callback: (...args: E[K]) => void,
): this {
    const callbacks = this.callbackMap.get(eventName as string);
    if (callbacks !== undefined) {
        callbacks.delete(callback as (...args: unknown[]) => void);
        if (callbacks.size === 0) {
            this.callbackMap.delete(eventName as string);
        }
    }
    return this;
}
```

✅ **off() メソッドは実装されている**

#### 問題点 (InstrumentStore.ts:47-60)
```typescript
bus
    .on("song.set.after", (song) => { ... })  // ❌ 削除されない
    .on("channel.add.after", (channel) => { ... })
    .on("channel.update.after", (channelId, patch) => { ... })
```

InstrumentStore は singleton なため、メモリリークの実際的リスクは低いですが、**コード品質**として改善の余地があります。

**推奨**: Store クラスに `dispose()` メソッドを追加して、リスナーを明示的に削除

---

### ✅ MEDIUM: ActionRegistry

**前回の結果**: 削除完了

**現在の状態**: ✅ **削除状態が維持されている**

---

## 2. 最新コミットの詳細分析

### コミット: "Re-implement editor scroll function"

**変更対象ファイル数**: 25+ ファイル
**主要な変更内容**:

1. **CanvasUIController のリファクタリング**:
   - `CanvasUIController.ts` → `PointerEventManager.ts` へのリネーム
   - 関連型の整理と再編成:
     - `CanvasUIDoubleClickEvent.ts` → `PointerEventManagerDoubleClickEvent.ts`
     - `CanvasUIPosition.ts` → `PositionSnapshot.ts`
     - その他型定義の統一

2. **PianoRoll/Editor の改善**:
   - スクロール機能の再実装
   - `Editor.ts` に EventBus 受け取り追加
   - `PianoRoll.ts` でのスクロール処理改善

3. **ParameterEditor の更新**:
   - 状態管理の改善
   - レンダリング処理の最適化

### 評価

**ポジティブな側面**:
- ✅ 命名の統一化 (Canvas→PointerEvent)
- ✅ 型定義の整理
- ✅ スクロール機能の実装確認

---

## 3. 新規に発見された課題

### 3.1 🔴 CRITICAL: 命名の不統一 - set/update の使い分けの曖昧さ

**問題度**: 高 - API インターフェースの理解が困難

#### Issue 1: Set vs Update の混在

**Song モデル** (models/Song.ts):
- L68: `setTitle(title)` - 全置換
- イベント: `"song.set"` (全置換) vs `"song.update"` (部分更新)

**Channel モデル** (models/Channel.ts):
- L65: `setNotes(newNotes)` - 全置換
- L93: `applyPatch(patch)` - 部分更新

**UseCase レイヤー**:
- `SetNotes` - イベント名: `"notes.set"` (全置換)
- `UpdateChannel` - イベント名: `"channel.update"` (部分更新)

**問題**: 「set」と「update」の意味が非対称
- モデル層では明示的に分かれているが
- API として呼び出す際に「どちらを使うべきか」が不明確

**推奨**:
```typescript
// Option A: 統一的な命名規約を確立
SetNotes // OK (全置換)
UpdateSong // OK (部分更新)
SetChannel // ❌ 避ける（SetNotes との一貫性）

// Option B: 命名を統一
ReplaceNotes // 全置換を明示的に
UpdateNotes // 部分更新
```

---

#### Issue 2: select/selectOnly の不明確さ

**Editor.ts** (L102, 108, 120):
```typescript
setSelectedNotes(selectedNoteIds)  // 全置換
selectNotes(noteIds)               // 追加
unselectNotes(noteIds)             // 削除
unselectAllNotes()                 // 全削除
```

**問題**: `setSelectedNotes()` と `selectNotes()` は逆の操作なのに、接頭辞が違う

**推奨**:
```typescript
replaceSelectedNotes(noteIds)  // 全置換
addSelectedNotes(noteIds)      // 追加
removeSelectedNotes(noteIds)   // 削除
clearSelectedNotes()           // 全削除
```

---

### 3.2 🟡 MEDIUM: 型キャストの乱用

**Location**: `src/ToolBar/ToolBar.tsx`

```typescript
const instrumentKey = activeChannel.instrumentKey as SoundFontInstrumentKey;
// 合計5箇所で同様のキャストが存在
```

**問題**:
- `InstrumentKey` はユニオン型で複数の種類がある
- 型チェックなしで キャストすると、実行時エラーのリスク
- 코드の意図が不明確

**推奨**: 型ガード関数の導入

```typescript
function isSoundFontInstrumentKey(key: InstrumentKey): key is SoundFontInstrumentKey {
    return "url" in key && "presetIndex" in key;
}

if (isSoundFontInstrumentKey(instrumentKey)) {
    const url = instrumentKey.url;  // ✅ 型安全
}
```

---

### 3.3 🟡 MEDIUM: marqueeArea の型定義の非対称性

**Issue**: ParameterEditor と PianoRoll で同じ名前のメソッドが異なる型を扱う

**ParameterEditor.ts** (L57, 63):
```typescript
setMarqueeAreaFrom(marqueeAreaFrom: number)
setMarqueeAreaTo(marqueeAreaTo: number)
```

**PianoRoll.ts** (L213, 218):
```typescript
setMarqueeAreaFrom(position: null | { key: number; tick: number })
setMarqueeAreaTo(position: null | { key: number; tick: number })
```

**問題**: 同じメソッド名なのに、パラメータ型が全く異なる

**推奨**:
- メソッド名を明示的に変更するか
- 共通の型定義を導入して統一

```typescript
// Option: 型を統一
type MarqueePosition = { key: number; tick: number } | null | number;
setMarqueeAreaFrom(position: MarqueePosition)
```

---

### 3.4 🟡 MEDIUM: PianoRoll.ts の複数責務

**Location**: `src/Editor/PianoRoll/PianoRoll.ts`

**問題**:
- ポインター操作ハンドリング (`PointerEventManagerDelegate` 実装)
- ドラッグ・リサイズ処理
- ホバー状態管理
- プレビュー音声再生
- ノート選択ロジック

**現在の行数**: ~500+ 行

**推奨**: 責務の分離
```typescript
// 提案する分割:
- PianoRollEventHandler // ポインター操作
- PianoRollSelection // 選択ロジック
- PianoRollPreview // プレビュー再生
- PianoRoll // メインコントローラー（統合）
```

**現状での影響**: 中程度 (単一責任原則の軽微な違反だが、保守性に影響)

---

### 3.5 🟢 LOW: useStateful フックの使用例が少ない

**Location**: 複数の React コンポーネント

**分析**:
```typescript
// アンチパターン（まれ）
const [state, setState] = useState<ListBoxState>(() => new ListBoxState());

// 推奨パターン（Select.tsx で使用）
const listBoxState = useStateful(listBoxController);
```

**現状**: 新規コンポーネント (ListBox, PopUp, Select) では useStateful が正しく使われています

**評価**: ✅ 良好

---

### 3.6 🟢 LOW: DI Container の使用パターンの一貫性

**Location**: `src/deps.tsx`

**現在の実装**:
```typescript
.set(Player.Key, (deps) => {
    return new Player(
        deps.get(AudioContextKey),
        deps.get(SongStore.Key),
        deps.get(InstrumentStore.Key),
        deps.get(EventBus.Key),
    );
})
```

**評価**: ✅ DI パターンは一貫して正しく使用されている

---

## 4. 改善優先度

### 🔴 CRITICAL (即座に対応)

| # | 項目 | 理由 | 推定工数 | ファイル |
|----|------|------|--------|---------|
| 1 | set/update の命名規約統一 | API の理解が困難 | 2-3h | 全体 |
| 2 | select/selectOnly の統一 | インターフェース明確化 | 1-2h | src/Editor/ |

---

### 🟡 HIGH (次スプリント)

| # | 項目 | 理由 | 推定工数 | ファイル |
|----|------|------|--------|---------|
| 3 | 型ガード関数の導入 (InstrumentKey) | 型安全性向上 | 1h | src/ToolBar/ |
| 4 | marqueeArea の型統一 | インターフェース統一 | 1h | src/Editor/ |
| 5 | EventBus listener cleanup | メモリ安全性 | 1h | src/*Store.ts |

---

### 🟢 MEDIUM (将来的)

| # | 項目 | 理由 | 推定工数 | ファイル |
|----|------|------|--------|---------|
| 6 | PianoRoll の責務分離 | 単一責任原則 | 4-6h | src/Editor/PianoRoll/ |

---

## 5. アーキテクチャ評価

### 5.1 層構造の安定性

```
┌──────────────────────────────────────────────────────┐
│        React Presentation Layer (Component)         │
│  AppView, ToolBar, ChannelListView, StatusBar       │
│  + ListBox, PopUp, Select, InstrumentSelect         │
├──────────────────────────────────────────────────────┤
│   Application Layer (Business Logic)                │
│   Editor, PianoRoll, ParameterEditor                │
│   PointerEventManager (renamed from CanvasUICtrl)   │
├──────────────────────────────────────────────────────┤
│   Use Case Layer (Phased-Event-based UseCases)      │
│   ✅ emitPhasedEvents で統一                         │
├──────────────────────────────────────────────────────┤
│   Infrastructure Layer (Event-driven)               │
│   EventBus (PhasedEvents), EditHistory, Stores     │
├──────────────────────────────────────────────────────┤
│   Domain Layer (Immutable Models)                   │
│   Song, Channel, Note, Instrument                   │
└──────────────────────────────────────────────────────┘
```

**評価**: ✅ 層構造は明確で安定している

### 5.2 DI パターンの有効性

**使用状況**: 全 12 のユースケース + 8 つの主要サービスが DI 経由で管理されている

**評価**: ✅ 非常に効果的
- テスト容易性が高い
- 依存性の解決が明示的
- Singleton パターンが一貫して適用されている

### 5.3 Immutable State パターン

**評価**: ✅ 継続して堅実に実装されている
- モデル層でのイミュータビリティ確保
- State 更新時の新規インスタンス生成
- React コンポーネント での副作用最小化

---

## 6. 総合評価

### 📊 スコア

| 指標 | スコア | コメント |
|------|--------|---------|
| アーキテクチャ | 9/10 | 層構造が明確で堅実 |
| Phased Events 実装 | 10/10 | 完全に統一された実装 |
| 命名の一貫性 | 6/10 | set/update が混在 ⚠️ |
| 型安全性 | 7/10 | 型キャストが存在 ⚠️ |
| コード保守性 | 8/10 | PianoRoll の肥大化懸念 |
| **総合スコア** | **8/10** | **安定した設計品質** |

---

### 強み ✅

1. **層構造の明確性**: Model → Use Case → Presentation まで関心が適切に分離
2. **Phased Events パターンの統一**: EventBus の設計パターンが完全に統一
3. **Immutable 設計**: State 管理の安全性が高い
4. **DI Container**: 依存性管理が明示的で拡張性に優れている
5. **新規コンポーネント品質**: ListBox, PopUp, Select の実装品質が高い

---

### 課題 ⚠️

1. **命名の不統一**: set/update と select/selectOnly の混在
2. **型安全性**: as キャストの乱用
3. **複雑性**: PianoRoll.ts の責務が多い
4. **Event Listener**: Store の listener cleanup が未実装

---

### 改善への推奨順序

**Phase 1 (1-2日)**: 命名規約統一
- set/update の使い分けをドキュメント化
- select*/selectOnly の命名を統一
- **目的**: API の理解性向上

**Phase 2 (1日)**: 型安全性強化
- 型ガード関数の導入
- as キャストを削除
- **目的**: 実行時エラーのリスク低減

**Phase 3 (将来的)**: 責務分離
- PianoRoll の分割
- **目的**: テスト容易性と保守性向上

---

## 備考

### 前回レビューでの懸念事項

前回レビューの最後に記載されていた「Select コンポーネントの Context ベースアプローチ」についての懸念：

> "本質的にやりたいことはReact.Childrenをつかった子要素の型による分岐なのですがReact.Childrenのような手続き型のアプローチは避けるべきという公式からの指針もあります。"

**現在の実装**:
```typescript
// Select.tsx での使用
<Select.Option key={i} value={i} label={preset.name} />
```

**評価**: ✅ 現在の実装は問題ない
- Select コンポーネントは `children` prop で柔軟に対応
- Option は宣言的に記述可能
- Runtime overhead は最小限

前回の懸念は既に設計上適切に対処されています。

---

## 結論

**コードベースの状態**: 8/10 (前回 8.8/10 から微調整)

**評価**:
- アーキテクチャは引き続き堅実
- Phased Events パターンが完全に統一され、ユースケース層が洗練されている
- 新規に加わった命名の不統一問題が主な課題

**推奨アクション**:
1. 命名規約を統一してコードの可読性を向上
2. 型ガード関数を導入して型安全性を強化
3. PianoRoll の責務分離を検討

**全体的な方向性**: ✅ **良好** - 堅実な基盤の上で、段階的な改善が推奨されます

---

**レビュー完了日**: 2025-12-14
**レビュー実施者**: Claude Code
**対象ファイル数**: 95+ TypeScript ファイル
**総コード行数**: ~11,500 行 (推定)
**比較対象**: REVIEW_RESULT_20251212_051246.md (前回レビュー)
